package authorization

import (
	"errors"
	"github.com/google/uuid"
	"github.com/ksensehq/eventnative/logging"
	"github.com/ksensehq/eventnative/resources"
	"github.com/spf13/viper"
	"strings"
	"sync"
	"time"
)

const serviceName = "authorization"

type Service struct {
	sync.RWMutex
	jsTokens  map[string][]string
	apiTokens map[string][]string
}

func NewService() (*Service, error) {
	service := &Service{jsTokens: map[string][]string{}, apiTokens: map[string][]string{}}

	reloadSec := viper.GetInt("server.auth_reload_sec")
	if reloadSec == 0 {
		return nil, errors.New("server.auth_reload_sec can't be empty")
	}

	authViper := viper.Sub("server.auth")
	if authViper != nil {
		service.jsTokens = parseFromConfig(authViper, "js")
		service.apiTokens = parseFromConfig(authViper, "api")
	} else {
		authSource := viper.GetString("server.auth")

		if strings.HasPrefix(authSource, "http://") || strings.HasPrefix(authSource, "https://") {
			resources.Watch(serviceName, authSource, resources.LoadFromHttp, service.updateTokens, time.Duration(reloadSec)*time.Second)
		} else if strings.Contains(authSource, "file://") {
			resources.Watch(serviceName, strings.Replace(authSource, "file://", "", 1), resources.LoadFromFile, service.updateTokens, time.Duration(reloadSec)*time.Second)
		} else if strings.HasPrefix(authSource, "{") && strings.HasSuffix(authSource, "}") {
			service.updateTokens([]byte(authSource))
		}
	}

	if len(service.jsTokens) == 0 && len(service.apiTokens) == 0 {
		//autogenerated
		generatedToken := uuid.New().String()
		service.jsTokens[generatedToken] = []string{}
		service.apiTokens[generatedToken] = []string{}
		logging.Warn("Empty 'server.auth.js' and 'server.auth.api' config keys. Auto generate token:", generatedToken)
	}

	return service, nil
}

func (s *Service) GetJsOrigins(token string) ([]string, bool) {
	s.RLock()
	defer s.RUnlock()

	origins, ok := s.jsTokens[token]
	return origins, ok
}

func (s *Service) GetAllTokens() map[string]bool {
	s.RLock()
	defer s.RUnlock()

	result := map[string]bool{}
	for k := range s.jsTokens {
		result[k] = true
	}
	for k := range s.apiTokens {
		result[k] = true
	}
	return result
}

func (s *Service) GetApiOrigins(token string) ([]string, bool) {
	s.RLock()
	defer s.RUnlock()

	origins, ok := s.apiTokens[token]
	return origins, ok
}

func (s *Service) updateTokens(payload []byte) {
	js, api, err := parseFromBytes(payload)
	if err != nil {
		logging.Errorf("Error updating authorization tokens: %v", err)
	} else {
		s.Lock()
		s.jsTokens = js
		s.apiTokens = api
		s.Unlock()
	}
}
