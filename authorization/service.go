package authorization

import (
	"encoding/json"
	"fmt"
	"github.com/google/uuid"
	"github.com/spf13/viper"
	"log"
	"strings"
	"sync"
)

const authTokensKey = "server.auth"
const s2sAuthTokenKey = "server.s2s_auth"

type Token struct {
	Value   string   `json:"token,omitempty"`
	Origins []string `json:"origins,omitempty"`
}

type Service struct {
	sync.RWMutex
	c2STokens map[string][]string
	s2STokens map[string][]string
}

func NewService() *Service {
	c2sTokens := map[string][]string{}
	s2sTokens := map[string][]string{}

	authTokens := viper.GetString("server.auth")
	s2sTokensArr := viper.GetStringSlice("server.s2s_auth")

	if len(c2sTokens) == 0 && len(s2sTokens) == 0 {
		//autogenerated
		generatedToken := uuid.New().String()
		c2sTokens[generatedToken] = []string{}
		s2sTokens[generatedToken] = []string{}
		log.Println("Empty 'server.tokens' config key. Auto generate token:", generatedToken)
	}

	return &Service{c2STokens: c2sTokens, s2STokens: s2sTokens}
}

func (s *Service) GetC2SOrigins(token string) ([]string, bool) {
	s.RLock()
	defer s.RUnlock()

	origins, ok := s.c2STokens[token]
	return origins, ok
}

func (s *Service) GetAllTokens() map[string]bool {
	s.RLock()
	defer s.RUnlock()

	result := map[string]bool{}
	for k := range s.c2STokens {
		result[k] = true
	}
	for k := range s.s2STokens {
		result[k] = true
	}
	return result
}

func (s *Service) GetS2SOrigins(token string) ([]string, bool) {
	s.RLock()
	defer s.RUnlock()

	origins, ok := s.s2STokens[token]
	return origins, ok
}

func (s *Service) reload(c2sTokens, s2sTokens map[string][]string) {
	s.Lock()
	s.c2STokens = c2sTokens
	s.s2STokens = s2sTokens
	s.Unlock()
}

func loadFromConfig(viperKey string) (map[string][]string, error) {
	tokensStrValue := viper.GetString(viperKey)
	if strings.HasPrefix(tokensStrValue, "[") && strings.HasSuffix(tokensStrValue, "]") {
		return loadFromBytes("app config json array", []byte(tokensStrValue))
	}

	tokensArr := viper.GetStringSlice(viperKey)
	tokensOrigins := map[string][]string{}
	for _, t := range tokensArr {
		trimmed := strings.TrimSpace(t)
		if trimmed != "" {
			tokensOrigins[trimmed] = []string{}
		}
	}

	return tokensOrigins, nil
}

func loadFromBytes(source string, b []byte) (map[string][]string, error) {
	var tokens []Token
	err := json.Unmarshal(b, &tokens)
	if err != nil {
		//try to unmarshal into []string
		var strTokens []string
		err := json.Unmarshal(b, &strTokens)
		if err != nil {
			return nil, fmt.Errorf("Error unmarshalling tokens from %s. Payload must be json array or string array: %v", source, err)
		}
		for _, t := range strTokens {
			tokens = append(tokens, Token{Value: t})
		}
	}

	tokensOrigins := map[string][]string{}
	for _, tokenObj := range tokens {
		trimmed := strings.TrimSpace(tokenObj.Value)
		if trimmed != "" {
			tokensOrigins[trimmed] = tokenObj.Origins
		}
	}

	return tokensOrigins, nil
}
