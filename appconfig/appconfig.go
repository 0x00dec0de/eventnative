package appconfig

import (
	"github.com/google/uuid"
	"github.com/ksensehq/tracker/events"
	"github.com/ksensehq/tracker/geo"
	"github.com/ksensehq/tracker/logging"
	"github.com/spf13/viper"
	"io"
	"log"
	"os"
	"strings"
)

type AppConfig struct {
	ServerName       string
	Authority        string
	AuthorizedTokens map[string]bool

	EventsConsumer events.Consumer
	GeoResolver    geo.Resolver

	closeMe []io.Closer
}

var Instance *AppConfig

func setDefaultParams() {
	viper.SetDefault("server.port", "8001")
	viper.SetDefault("geo.maxmind_path", "/home/tracker/app/res/")
	viper.SetDefault("log.main.type", "stdout")
	viper.SetDefault("log.main.path", "/home/tracker/logs/")
	viper.SetDefault("log.event.type", "file")
	viper.SetDefault("log.event.path", "/home/tracker/logs/events")
	viper.SetDefault("log.event.rotation_min", "5")
}

func Init() error {
	setDefaultParams()

	serverName, err := os.Hostname()
	if err != nil {
		log.Println("Unable to get os hostname", err)
		serverName = "unnamed-server"
	}

	if err := logging.InitGlobalLogger(logging.Config{
		LoggerName:  "main",
		LoggerType:  viper.GetString("log.main.type"),
		ServerName:  serverName,
		FileDir:     viper.GetString("log.main.path"),
		RotationMin: viper.GetInt64("log.main.rotation_min"),
		MaxBackups:  viper.GetInt("log.main.max_backups")}); err != nil {
		log.Fatal(err)
	}

	log.Println(" *** Creating new AppConfig *** ")
	log.Println("Server Name:", serverName)
	publicUrl := viper.GetString("server.public_url")
	if publicUrl == "" {
		log.Println("Server public url: will be taken from Host header")
	} else {
		log.Println("Server public url:", publicUrl)
	}

	var appConfig AppConfig
	appConfig.ServerName = serverName

	port := viper.GetString("port")
	if port == "" {
		port = viper.GetString("server.port")
	}
	appConfig.Authority = "0.0.0.0:" + port

	geoResolver, err := geo.CreateResolver(viper.GetString("geo.maxmind_path"))
	if err != nil {
		log.Println("Run without geo resolver", err)
	}
	appConfig.GeoResolver = geoResolver

	//authorization
	// 1. from config
	tokensArr := viper.GetStringSlice("server.auth")
	authorizedTokens := map[string]bool{}
	for _, token := range tokensArr {
		if token != "" {
			authorizedTokens[strings.TrimSpace(token)] = true
		}
	}
	if len(authorizedTokens) == 0 {
		// 2. autogenerated
		generatedToken := uuid.New().String()
		authorizedTokens[generatedToken] = true
		log.Println("Empty 'server.tokens' config key. Auto generate token:", generatedToken)
	}

	appConfig.AuthorizedTokens = authorizedTokens

	//loggers per token
	writers := map[string]io.WriteCloser{}
	for token := range appConfig.AuthorizedTokens {
		eventLogWriter, err := logging.NewWriter(logging.Config{
			LoggerName:  "event-" + token,
			LoggerType:  viper.GetString("log.event.type"),
			ServerName:  serverName,
			FileDir:     viper.GetString("log.event.path"),
			RotationMin: viper.GetInt64("log.event.rotation_min"),
			MaxBackups:  viper.GetInt("log.event.max_backups")})
		if err != nil {
			return err
		}
		writers[token] = eventLogWriter
	}

	appConfig.EventsConsumer = events.NewMultipleAsyncLogger(writers)
	appConfig.ScheduleClosing(appConfig.EventsConsumer)

	Instance = &appConfig
	return nil
}

func (a *AppConfig) ScheduleClosing(c io.Closer) {
	a.closeMe = append(a.closeMe, c)
}

func (a *AppConfig) Close() {
	for _, cl := range a.closeMe {
		if err := cl.Close(); err != nil {
			log.Println(err)
		}
	}
}
